/*
 * Copyright 2022 American Express Travel Related Services Company, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

import fs from 'node:fs';
import generateIntegrityManifest from '../../../esbuild/plugins/generate-integrity-manifest';
import { runSetupAndGetLifeHooks } from './__plugin-testing-utils__';

jest.mock('node:fs', () => ({
  promises: {
    readFile: jest.fn(() => 'mockFileContent'),
  },
  readFileSync: jest.fn(() => 'mockFileContent'),
  writeFileSync: jest.fn(() => 'mockWriteFileResponse'),
}));

describe('Esbuild plugin generateIntegrityManifest', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should be a function that returns a plugin with the correct name', () => {
    const plugin = generateIntegrityManifest({ bundleName: 'mockBundleName' });
    expect(plugin.name).toBe('generateIntegrityManifest');
  });

  describe('setup function', () => {
    it('should register an onEnd hook and an onStart hook', () => {
      const plugin = generateIntegrityManifest({ bundleName: 'mockBundleName' });
      const lifeCycleHooks = runSetupAndGetLifeHooks(plugin);

      expect(lifeCycleHooks.onEnd.length).toBe(1);
    });
  });

  describe('lifecycle Hooks', () => {
    describe('onEnd', () => {
      it('should generate a manifest based upon the content of the first file, and write a new file if the loaded manifest cant be parsed', async () => {
        expect.assertions(9);
        const plugin = generateIntegrityManifest({ bundleName: 'mockBundleName' });
        const hooks = runSetupAndGetLifeHooks(plugin);
        const onEnd = hooks.onEnd[0];
        // first read is the bundle generated by the build
        fs.promises.readFile.mockImplementationOnce(() => 'mockModuleFileContent');
        // second read is loading the existing manifest
        fs.readFileSync.mockImplementationOnce(() => '} Mock Bad JSON File');

        const mockResult = { metafile: { outputs: { '/path/to/bundle.js': {} } } };
        const results = await onEnd(mockResult);

        expect(fs.promises.readFile).toHaveBeenCalledTimes(1);
        expect(fs.readFileSync).toHaveBeenCalledTimes(1);
        expect(fs.promises.readFile).toHaveBeenCalledWith('/path/to/bundle.js', 'utf8');
        expect(fs.readFileSync).toHaveBeenCalledWith('./bundle.integrity.manifest.json', 'utf8');

        expect(fs.writeFileSync).toHaveBeenCalledTimes(1);
        // first parameter of first call
        expect(fs.writeFileSync.mock.calls[0][0]).toBe('./bundle.integrity.manifest.json');
        // Snapshot here for the hash. Its hashing the response from the first readFile mock,
        // 'mockModuleFileContent', therefore if the hash below ever changes, its likely to be
        // generating hashes that one app will reject, unless the holocron hash checking algorithm
        // is also changed
        expect(fs.writeFileSync.mock.calls[0][1]).toMatchInlineSnapshot(`
"{
  \\"mockBundleName\\": \\"sha256-dVDfvIfLZ/EauFs99M0kCfTCNSTcAaeR8tIfSmPWMBU= sha384-bkhDhTm0NmB0SvMS9As2gTFJ86GfZIOyXBPzQPCTmtoDXvQTaTrNqe6skXgbJNT7\\"
}"
`);

        expect(results).toBe(mockResult);
        expect(results).toStrictEqual(mockResult);
      });

      it('should generate a manifest based upon the content of the first file, and preserve existing keys in the loaded manifest', async () => {
        expect.assertions(9);
        const plugin = generateIntegrityManifest({ bundleName: 'mockBundleName' });
        const hooks = runSetupAndGetLifeHooks(plugin);
        const onEnd = hooks.onEnd[0];

        // read bundle generated by the build
        fs.promises.readFile.mockImplementationOnce(() => 'mockModuleFileContent 2'); // A different content here that the other test, just to get a different set of hashes
        // this read is loading the existing manifest
        fs.readFileSync.mockImplementationOnce(() => '{"existingKey": "existing value"}');

        const mockResult = { metafile: { outputs: { '/path/to/bundle.js': {} } } };
        const results = await onEnd(mockResult);

        expect(fs.promises.readFile).toHaveBeenCalledTimes(1);
        expect(fs.readFileSync).toHaveBeenCalledTimes(1);
        expect(fs.promises.readFile).toHaveBeenCalledWith('/path/to/bundle.js', 'utf8');
        expect(fs.readFileSync).toHaveBeenCalledWith('./bundle.integrity.manifest.json', 'utf8');

        expect(fs.writeFileSync).toHaveBeenCalledTimes(1);
        // first parameter of first call
        expect(fs.writeFileSync.mock.calls[0][0]).toBe('./bundle.integrity.manifest.json');
        // Snapshot here for the hash. Its hashing the response from the first readFile mock,
        // 'mockModuleFileContent 2', therefore if the hash below ever changes, its likely to be
        // generating hashes that one app will reject, unless the holocron hash checking algorithm
        // is also changed
        expect(fs.writeFileSync.mock.calls[0][1]).toMatchInlineSnapshot(`
"{
  \\"existingKey\\": \\"existing value\\",
  \\"mockBundleName\\": \\"sha256-Zm5CQBMv8j1wfIwc9CduHNb/5B1h3BfFW90PQRrSmgw= sha384-LOx8uPLWAGDBDR/d0IcytHhmTNkHzpBackOMoTLZUVx/s2gE9F1Wb19Q6k+xXt1s\\"
}"
`);

        expect(results).toBe(mockResult);
        expect(results).toStrictEqual(mockResult);
      });

      it('should do nothing if there is no results metadata', async () => {
        expect.assertions(2);
        const plugin = generateIntegrityManifest({ bundleName: 'mockBundleName' });
        const hooks = runSetupAndGetLifeHooks(plugin);
        const onEnd = hooks.onEnd[0];
        await onEnd({});

        expect(fs.promises.readFile).not.toHaveBeenCalled();
        expect(fs.writeFileSync).not.toHaveBeenCalled();
      });
    });
  });
});
